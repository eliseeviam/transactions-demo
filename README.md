# Transactions demo
Transactions demo for my Community-Z lecture

Информационные системы оперируют с ресурсами: будь-то банковский счет или имя пользователя.

Когда необходимо данные прочитать, то всё ок. 

# ACID

Для решения этой проблемы существуют транзакции. Транзакция это абстракция для программистов, которая заявляет, что операции которые ты выполнишь в рамках транзакции или выполнятся целиком, или не выполнятся вовсе. Это Атомарность и Прочность. По-нашему, Atomicity и Durability. 

Также есть понятие консистентности (Consistency). Консистентность – это гарантия, которая заявляет, что если до начала транзакции СУБД была консистентна, то после успешного коммита она останется консистентной.

И наконец Изолированность (Isolation) – гарантия заявляющая о том, что результат выполнения конкурентных транзакций будет такой же как при последовательном выполнении эти же транзакций. 

# Isolation

Если бы СУБД давала эту гарантию из коробки, то это бы работало очень плохо, или СУБД была бы VoltDB[1] или Redis(но мы тут про реляционные). 

Для того, чтобы определить решение нужно сначала понять проблему. Разберем на примерах.

## Проблемы

Иначе назваются явление(phenomena) или феномены.

### Lost update

Ситуация в которой несколько параллельных транзакций меняют один ресурс, но изменения одной из транзакций теряются.;

```sql
// Транзакция 1
UPDATE score = score + 1 WHERE user_id = 1; // T1

// Транзакция 2
UPDATE score = score + 2 WHERE user_id = 1; // T1
```

Две транзакции в один момент времени изменяют одну запись. Ожидается, что score увеличится на 3, но по факту поведение неопределено. 

### Dirty read

```sql
scope = 10
// Транзакция 1
UPDATE score = score + 1 WHERE user_id = 1; // T1
ROLLBACK;  // T3

// Транзакция 2
SELECT score FROM scores WHERE user_id = 1; // T2
// score = 11
```

Транзакция 1 обновляет запись, транзакция 2 читает обновленные данные, транзакция 1 откатывается. В итоге транзакция 2 получила данные, который в базе отсутствуют.

### Non-repeatable read

```sql
score = 10
// Транзакция 1
UPDATE score = score + 1 WHERE user_id = 1; // T2
COMMIT; // T3

// Транзакция 2
SELECT score FROM scores WHERE user_id = 1; // T1
// 10
SELECT score FROM scores WHERE user_id = 1; // T4
// 11
```

Транзакция 2 читает данные, потом транзакция 1 их обновляет и фиксирует. Транзакция 2 читает данные повторно. Ещё одно проявление такого феномена это снимок неконсистентного состояния. В этой ситуации при чтении большого объема данных вычитываются данные с состоянием на разные моменты времени. Что может привести к логической несогласованности снятого с БД бэкапа или дампа для бухгалтерии. 

### Phantom read

```sql
INSERT INTO accounts (user_id, account) VALUES (1, 'first'), (1, 'second')

// Транзакция 1
SELECT COUNT(*) FROM accounts WHERE user_id = 1; // T1
// 2
if count >= 3 {
	ROLLBACK;
	return
}
INSERT INTO accounts (user_id, account) VALUES (1, 'third') // T3
COMMIT;

// Транзакция 2
SELECT COUNT(*) FROM accounts WHERE user_id = 1; // T2
// 2
if count >= 3 {
	ROLLBACK;
	return
}
INSERT INTO accounts (user_id, account) VALUES (1, 'third')// T4
COMMIT;

SELECT COUNT(*) FROM accounts WHERE user_id = 1;
// 4
```

Транзакция 1 считает сумму очков в таблице, транзакция 2 добавляет запись, транзакция 1 повторно считает сумму очков в таблице – результат изменился. Тут проблема возникает из-за добавления или удаления строк, а не из-за измененения существующей строки, как в проблеме неповторяющегося чтения.

Такой пример актуален для случая когда есть ограничение по количеству. Например, пользователю запрещено иметь более трех счетов, как в примере выше.

### Итого

Были перечислены основные аномалии. На самом деле, проблема синхронизации нетривиальная и каждую проблему следует рассматривать индивидуально. Ну и фактически аномалий значительно больше, чем в стандарте. 

Для устранения задокументированных аномалий используются следующие уровни изоляции.

## Уровни изоляции

### Read uncommitted

Гарантия тут одна – выполнение нескольких параллельных операций будет выполнено последовательно, но не факт, что логически согласованно. Операции чтения не требуют фиксации данных.

Обычно реализуется через блокировку изменяемых строк.

По факту, в реляционных СУБД по умолчанию используются более строгие уровни изоляции: MySQL - Repeatable Read[2], PostgerSQL - Read Commited[3], Oracle – Read Comminted[4].   

### Read commited

Помимо гарантий уровня Read uncommitted добавлется гарантия того, что читаемые данные будут зафиксированны. 

Реализуется или блокировками, или снэпшотами. 

В случае PostgerSQL. Для запросов `SELECT` используются снэшпоты базы на момент начала выполнения запросы (именно запроса, а не транзакции). В случае запросов `UPDATE`, `DELETE`, `SELECT FOR UPDATE` и `SELECT FOR SHARE` поведение аналогичное, но меняющая транзакция будет дожидаться фиксации или отката более ранней меняющей транзакции. 

### Repeatable read

Позволяет при многократном считывании одной и той же строки в рамках одной транзакции получать одно и то же значение даже если конкурентная транзакция его изменила. Данный уровень изоляции реализуется с помощью подхода MVCC или  multiversion concurrency control.

**Multiversion concurrency control**

Уровень изоляции ReadCommited требует хранения только 2 версий строки: зафиксированной и грязной. Но уровень изоляции RepeatableRead требует изоляции уже зафиксированных данных. В этом случае нужно хранение нескольких версий данных. 

В двух словах работает так. В самом начале выполнения транзакция получает уникальный, монотонно возрастающий идентификатор транзакции (txid). При каждой записи транзакцией записываемые в базу данные помечаются номером этой транзакции. В каждой строке таблицы есть поле created_by, содержащее идентификатор транзакции, вставившей эту строку в таблицу. Более того, в каждой строке таблицы есть поле deleted_by, изначально пустое. Такие образом получаем версионирование строк. А значит, что нашей транзакции необходимо работать только со строками с txid меньшими или равным txid текущей транзакции. 

### Serializable

Принятие решений на основании неактуальных данных и SERIALIZABLE, 2PL , .

**2PL – Two-Phase Lock**

Строгие правила. При двухфазной блокировке записывающие транзакции блокируют и другие записывающие транзакции, и читающие и наоборот. Правило изоляции
снимков состояния — *читающие транзакции никогда не блокируют записывающие,
а записывающие никогда не блокируют читающие*

**Предикатные блокировки и блокировки по диапазону значений индекса**

Подход, позволяющий блокировать не конкретные строки, строки подходящие под условие. Пишут, что до реализации в системах дело не дошло. 

**Сериализуемая изоляция снимков состояния (SSI)**

Serializable Shapshot Isolation[5] довольно свежий алгоритм. В нем используется оптимистический подход, благодаря чему транзакции выполняются без блокировок. Перед фиксацией транзакции выполняется проверка, и если выполнение было несериализуемым, то транзакция прерывается без фиксации. В PostgreSQL SSI используется для реализации уровеня изоляции SERIALAZABLE начиная с версии 9.1[10].

# Tips and tricks

## Атомарные обновления

```sql
UPDATE a = a + 1 WHERE id = 123;
```

## Явные блокировки

Если две транзакции принимают решение на основании одних и тех же данных, а потом эти данные меняют, то может произойти так называемая ассиметрия записи. Для решения этой проблемы можно использовать явные блокировки. В этом случае все строки подходящие под условие будут заблокированны до завершения транзакции.

```sql
SELECT ... FOR UPDATE
```

```sql
SELECT * FROM on_call
     WHERE on_call = true
     AND shift_id = 1 FOR UPDATE;
  
UPDATE on_call
     SET on_call = false
     WHERE name = 'Alice'
     AND shift_id = 1;
COMMIT;
```

Для обработки отложенных задач можно использовать следующую конструкцию. В отличии от первой, ранее выбранные и заблокированные записи будут пропущены. 

```sql
SELECT job_id, description FROM jobs 
		WHERE done = false FOR UPDATE SKIP LOCKED LIMIT 1;

// do job 

UPDATE jobs 
		SET done = true
		WHERE job_id = job_id;

COMMIT;
```

## Сравнение с обменом

```sql
UPDATE value = 5, version = 'version2' WHERE id = 123 AND version = 'version1';
```

## **Материализация конфликтов**

Проблема с фантомным чтением возникает из-за того, что не существует объекта на который можно повесить блокировку. То почему бы его не создать явно. На примере с ограниченным количеством счетов можно было бы предсоздать неинициализированные счета заранее. Такой подход называется *Материализация конфликтов.*

```sql
INSERT INTO accounts (user_id, account, inited) 
		VALUES (1, 'first', false), (1, 'second', false), (1, 'third', false);

// Транзакция 1
SELECT * FROM accounts WHERE user_id = 1 AND inited IS FALSE FOR UPDATE; // T1
// 3
if count == 0 {
	ROLLBACK;
	return
}
UPDATE accounts SET inited = true WHERE account = 'first' // T3
COMMIT;

// Транзакция 2
SELECT * FROM accounts WHERE user_id = 1 AND inited IS FALSE FOR UPDATE; // T1
// 2
if count == 0 {
	ROLLBACK;
	return
}
UPDATE accounts SET inited = true WHERE account = 'second' // T3
COMMIT;
```

В общем, это пожалуй один из самых кривых вариантов. И возможно лучшим вариантом тут будет именно сериализуемость.

## Рекомендательные локи

В PostgreSQL есть полезный инструмент рекомендательных блокировок – pg_advisory_lock[6]. По сути это application-defined блокировки и приложение само определяет что блокировать и как. Есть блокировки уровня сессии и уровня транзакции(xact). Есть эксклюзивные и разделяемые(shared). Пессимистичные и оптимистичные(try). Вариантов задать 2: int64 значением или парой int32. 

⚠️ Приложение само несет ответственность за такую блокировку. Если блокировка транзакционного уровня будет снята по завершению транзакции, то сеансовая снимается приложением или по завершению сеанса.

⚠️ Такие блокировки никак не конфликтуют с уровнями изоляции транзакций. 

Например, вот так может выглядеть решение проблемы с ограниченным количеством счетов. Первая транзакция захватывает блокировку, а последующие будут ожидать её завершения. По сути имеем распределенный мьютекс.

```sql
SELECT pg_advisory_xact_lock(user_id);  // берем блокировку 
																				// ресурса на уровне транзакции
  
SELECT COUNT(*) FROM accounts WHERE owner = user_id
if count >= 3 {
		ROLLBACK;
}
INSERT INTO accounts (owner, name) VALUES (user_id, 'account_name');
COMMIT;
```

Рекомендательные блокировки можно использовать и для монопольного доступа к ресурсам или с целью защиты от повторного запуска “тяжелых” операций типа выгрузки отчетов в CRM и прочие админки. Менеджеры обычно не очень терпеливы)

## **Распределенные блокировки**

Подобное решение лишь одно из группы распределенных бликоровок. Вот есть пример на базе редиса[7]. 

# Немного про распределенные транзакции

Распределенных транзакций касаться не будем. Отмечу лишь пару моментов. Частый паттерн поведения это “Изменить ресурс – Отправить событие”. И это нужно выполнить транзакционно. Но в один шаг такое не делается. Потому используется комбинация подходов:

1. Транзакция на изменение. В этой же транзакции отдельным запросом или триггером происходит вставка события в специальную таблицу;
2. Некоторый агент читает события из этой таблицы и отправляет их, например, через брокер сообщений. **Требуется**, чтобы получатели событий умели в идемпотентность.

Такой подход называется Transactional Outbox[8]. Существует его вариация – Transaction Log Tailing[9]. Это тоже самое, но вместо таблицы используется write-ahead-log или иные схожие по смыслу механизмы СУБД.

# А что внутри?

Тут можно указать какие-то ссылочки. Так как топик в тему, но на пару часов.

# Ссылки

1. [https://docs.voltdb.com/UsingVoltDB/IntroHowVoltDBWorks.php](https://docs.voltdb.com/UsingVoltDB/IntroHowVoltDBWorks.php);
2. [https://dev.mysql.com/doc/refman/8.0/en/set-transaction.html](https://dev.mysql.com/doc/refman/8.0/en/set-transaction.html);
3. [https://www.postgresql.org/docs/14/transaction-iso.html](https://www.postgresql.org/docs/14/transaction-iso.html);
4. [https://docs.oracle.com/cd/E15586_01/server.1111/e25789/consist.htm](https://docs.oracle.com/cd/E15586_01/server.1111/e25789/consist.htm);
5. [https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf);
6. [https://postgrespro.ru/docs/postgresql/12/explicit-locking#ADVISORY-LOCKS](https://postgrespro.ru/docs/postgresql/12/explicit-locking#ADVISORY-LOCKS);
7. [https://github.com/go-redsync/redsync](https://github.com/go-redsync/redsync);
8. [https://microservices.io/patterns/data/transactional-outbox.html](https://microservices.io/patterns/data/transactional-outbox.html);
9. [https://microservices.io/patterns/data/transaction-log-tailing.html](https://microservices.io/patterns/data/transaction-log-tailing.html);
10. [https://drkp.net/papers/ssi-vldb12.pdf](https://drkp.net/papers/ssi-vldb12.pdf);